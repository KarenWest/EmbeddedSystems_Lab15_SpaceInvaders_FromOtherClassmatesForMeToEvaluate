// slider pot parameters: to be adjusted depending on slider used
#define LOWSLIDER 		0xFFF // ADC slider value for low screen player position
#define HIGHSLIDER 		0x001 // ADC slider value for high screen player position
#define STEPSLIDER  	(unsigned long) ((LOWSLIDER - HIGHSLIDER) / SCREENHEIGHT) // ADC slider value for max screen position
	
#define LANDSPEED 						1

// fixed parameters for sprites
#define PLAYERFRAMES 					2
#define PLAYERFRAMESSIZE			175
#define PLAYERSPEED 					1

#define PLAYERROCKETFRAMES 		1
#define PLAYERROCKETFRAMESSIZE 131
#define PLAYERROCKETSPEED 		1

#define ENEMY1FRAMES 					2
#define ENEMY1FRAMESIZE			147

#define ENEMY2FRAMES 					2
#define ENEMY2FRAMESIZE			159

#define ENEMYROCKETFRAMES 		1
#define ENEMYROCKETFRAMESSIZE	131
#define ENEMYROCKETSPEED 			1

#define BIGEXPLFRAMES 				2
#define BIGEXPLFRAMESFRAMESSIZE	215
#define BIGEXPLFRAMESSPEED 		2

// max sprite arrays dimensions
#define MAXENEMY        			10
#define MAXENEMYROCKETS   		10
#define MAXPLAYERROCKETS 			2
#define MAXEXPLOSIONS   			3

// number of player lives 
#define PLAYERMAXLIVES    		4

// set true if you want player not killable
// (for debug purposes)
#define UNBREAKABLE    				0

// screen messages
const unsigned char MSG_WIN[] = "YOU WIN!";
const unsigned char MSG_OVER[] = "GAME OVER";
const unsigned char MSG_LVL[] = "LEVEL";
const unsigned char MSG_KILLED[] = "KILLED!";
const unsigned char MSG_KEY[] = "PRESS FIRE";
const unsigned char MSG_START[] = "DEFENDER";
const unsigned char MSG_LIVES[] = "LIVES LEFT";

// structure containing parameters
// for a single game level
struct TypeGameLevel {
	unsigned char Number; // level number
  unsigned char EnemyRndGen; // decreasing this number means more enemies
	                           // (probability to have a new level every frame
	                           // is 1/EnemyRndGen)
  unsigned char EnemyRocketRndGen; // decreasing this number means more enemy rockets
	unsigned char EnemySpeedX; // increasing this number means faster enemies
	unsigned char EnemySpeedY; // increasing this number means faster enemies 
	unsigned char EnemyTotNumber; // total number of enemies to kill to finish level
};

// array containing parameters for 3 game levels
struct TypeGameLevel Levels[3];
	
unsigned char CurrentLevel; // current level played
unsigned char PlayerLifesLeft; // lifes left to the player
unsigned char Debounce; // used for keys debouncing
unsigned long Semaphore;
unsigned long Rnd, Range;
unsigned long FrameNum;
unsigned char Armageddon; // true if player has already used
												  // armageddon key (PE1)
unsigned long InvertScreen; // if not zero, generate a screen flickering


void DisableInterrupts(void); // Disable interrupts
void EnableInterrupts(void);  // Enable interrupts

extern char screen[];

// screen dimension in pixel
#define SCREENHEIGHT	48
#define SCREENWIDTH 	84

// directions for a sprite
#define DIRUP 				0
#define DIRDOWN 			1
#define DIRLEFT 			0
#define DIRRIGHT 			1
#define DIRSTOP 			2

// life conditions for a sprite
#define DEAD 					0
#define ALIVE   			1
																	
// manages inputs from switch buttons on PE0 and PE1
// PE0 is "Fire1"
// PE1 is "Fire2"

#define FIRE1 		0x01
#define FIRE2 		0x02
#define BOTHFIRE 	0x03

																	
//-------------------------------------------
// structure describing a generic sprite;
//    *frames is the pointer to images array
//    nframes is the number of images for animation
//    speedx/speedy are speed rates for X/Y sprite movements
//        (Ex.: if speedx = 3, the sprite moves a pixel in X direction
//               every 3 screen frames)
//-------------------------------------------
struct SpriteType {
	const unsigned char *frames; // pointer to frames array
	unsigned char nframes; // number of frames
	unsigned long framesize; // size in bytes of single frames
	unsigned char actualframe; // actual frame number displayed
	unsigned char posx, posy; // actual sprite position in screen coords
	unsigned char dimx, dimy; // sprite dimensions in pixels
	unsigned char speedx; // X axis speed, i.e number of screen frames for every step
	unsigned char actualspeedx; // current number of screen frames to be waited before next X axis movement
	unsigned char speedy; // Y axis speed, i.e number of screen frames for every step
	unsigned char actualspeedy; // current number of screen frames to be waited before next Y axis movement
	unsigned char dirx; // current X axis direction (0=left, 1 =right, 2=no move)
	unsigned char diry; // current Y axis direction (0=up, 1 =down, 2=no move)
	unsigned char live; // sprite state: 1 = alive, 0 = dead
};

//------------------------------------------------------------------------
// structure describing the terrain;
//------------------------------------------------------------------------
struct TerrainType {
	// collects 84 points describing Y coord of the terrain landscape for every X coordinate
	unsigned char landscape[SCREENWIDTH];
	 // current number of screen frames to be waited before next movement
	unsigned char actualspeed;
	 // X axis speed, i.e number of screen frames to be waited for every movement
	unsigned char speed;
};


// arrays containing sprites generated during the game;
// every component contains a living sprite if Sprite.live = 1;
// to kill a sprite set live = 0
// to create a sprite, search for an empty component (live=0)
struct SpriteType Enemies[MAXENEMY];
struct SpriteType Prockets[MAXPLAYERROCKETS];
struct SpriteType Erockets[MAXENEMYROCKETS];
struct SpriteType Explosions[MAXEXPLOSIONS];

struct SpriteType Player; // player sprite
struct TerrainType Terrain; // terrain


// player ship frames array
const unsigned char PlayerImages[2][175] = {
{
 0x42, 0x4D, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
 0xF0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xF0, 0xFF, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF,
 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF
},
{
 0x42, 0x4D, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,
 0xF0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0xF0, 0xFF, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0x0F,
 0xF0, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF
}
};

// Enemy type 1 frames array
const unsigned char Enemy1Images[2][147] = {
{
 0x42, 0x4D, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x0F, 0x00,
 0x00, 0xF0, 0xFF, 0x00, 0x00, 0xFF, 0x0F, 0x00, 0x00, 0xF0, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0xFF
},
{
 0x42, 0x4D, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x0F, 0xFF,
 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0xFF
}
};

// Enemy type 2 frames array
const unsigned char Enemy2Images[2][159] = { 
{
 0x42, 0x4D, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
},{
 0x42, 0x4D, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,
}
};

// Player rocket frames array
const unsigned char PlayerRocketImages[1][131] = {
 0x42, 0x4D, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x00, 0xF0, 0x00,
 0x00, 0x00, 0xFF
};

//const unsigned char EnemyRocketImages[2][143] = {{
// 0x42, 0x4D, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
// 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
// 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0x0F,
// 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0xFF
//},
//{
// 0x42, 0x4D, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
// 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
// 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
// 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x0F, 0x0F,
// 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00, 0xFF

//}};

// Enemy rocket frames array
const unsigned char EnemyRocketImages[1][131] ={
 0x42, 0x4D, 0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xFF, 0xF0, 0x00, 0x00, 0x0F, 0x00,
 0x00, 0x00, 0xFF,
};

// Explosion frames array
const unsigned char  BigExplosionImages[2][215] = {{
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0A, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x90, 0x00, 0x90, 0xB0, 0x0A, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xA0, 0x00, 0xE0, 0x00, 0x00,
 0x90, 0x90, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0xA0, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00,
 0x00, 0xE0, 0x0A, 0x0A, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x09, 0x00, 0x00, 0x00, 0x90, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xFF
},
{
 0x42, 0x4D, 0xD6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x80,
 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0xFF,
 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0xB0, 0x00, 0xA0, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 0x00, 0x90,
 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x0A, 0x00, 0x90, 0x00, 0xB0, 0x00, 0x09, 0x00, 0x00, 0x00, 0xFF
}};

//------------------------------------------------------------------------
// generic movement of an external controlled sprite (player);
// moves sprite to destx/desty destination
//------------------------------------------------------------------------
void MoveSpriteMan(struct SpriteType *Sprite, signed char destx, signed char desty) {
		unsigned char moved;
	
	if (Sprite->live) {
	
		moved = 0;
		
		// adjusts excessive X destination
		if (destx > (SCREENWIDTH - Sprite->dimx)){
			destx = SCREENWIDTH - Sprite->dimx;
		}
		
		// adjusts excessive Y destination
		if (desty > SCREENHEIGHT){
			desty = SCREENHEIGHT;
		}
		if (desty < Sprite->dimy){
			desty = Sprite->dimy;
		}
		
		// decrements frames to wait for next movement
		Sprite->actualspeedx--;
		Sprite->actualspeedy--;
		
		// it's time to move sprite along X axis
		if (!Sprite->actualspeedx && destx != -1) {
			moved = 1;
			Sprite->actualspeedx = Sprite->speedx;
			if (Sprite->posx < destx) { // right X movement
				Sprite->posx++;
			}
			if (Sprite->posx > destx) { // left X movement
				Sprite->posx--;
			}
		}
		
		// it's time to move sprite along Y axis
		if (!Sprite->actualspeedy && desty != -1) {
			moved = 1;
			Sprite->actualspeedy = Sprite->speedy;
			if (Sprite->posy > desty) { // up Y movement
				Sprite->posy--;
			}
			if (Sprite->posy < desty) { // down Y movement
				Sprite->posy++;
			}
		}
		
		// if sprite must be moved, calculate next frame to display
		if (moved) {
			 Sprite->actualframe = (Sprite->actualframe + 1) % Sprite->nframes;
		}
	}
}



//------------------------------------------------------------------------
// display a sprite
//------------------------------------------------------------------------
void Nokia5110_DisplaySprite(unsigned char *image, unsigned char xpos, unsigned char ypos){
	
	Nokia5110_PrintBMP(xpos, ypos, image, 0);
	
}

//------------------------------------------------------------------------
// generic movement of an autonomous sprite (enemies, rockets);
// moves sprite in actual direction x and y
//------------------------------------------------------------------------
void MoveSpriteAuto(struct SpriteType *Sprite) {
	
	unsigned char moved;
	
	if (Sprite->live) {
	
		moved = 0;
		
		// decrement frames to wait for next movement
		Sprite->actualspeedx--;
		Sprite->actualspeedy--;
		
		// it's time to move sprite along X axis
		if (!Sprite->actualspeedx && Sprite->dirx != 2) {
			moved = 1;
			Sprite->actualspeedx = Sprite->speedx;
			if (!Sprite->dirx) { // left X movement
				Sprite->posx--; // update X coord
			}
			if (Sprite->dirx == 1) { // right X movement
				Sprite->posx++; // update X coord
			}
		}
		
		// it's time to move sprite along Y axis
		if (!Sprite->actualspeedy && Sprite->diry != 2) {
			moved = 1;
			Sprite->actualspeedy = Sprite->speedy;
			if (!Sprite->diry) { // up Y movement
				Sprite->posy--; // update Y coord
			}
			if (Sprite->diry == 1) { // down Y movement
				Sprite->posy++; // update Y coord
			}
		}
		
		// if sprite must be moved, calculate next frame to display
		if (moved) {
			 Sprite->actualframe = (Sprite->actualframe + 1) % Sprite->nframes;
		}
	}
	
}

//------------------------------------------------------------------------
// explosion animation
//------------------------------------------------------------------------
void AnimateExplosion(struct SpriteType *Sprite) {
	
	if (Sprite->live) {
	
		// decrement frames to wait for next frame
		Sprite->actualspeedx--;
		
		// explosion has finished: it's dead
		if (Sprite->actualframe == Sprite->nframes) {
				Sprite->live = 0;
		}	else {
			// it's time to animate the explosion
			if (!Sprite->actualspeedx) {
				Sprite->actualspeedx = Sprite->speedx;
				Sprite->actualframe++; // update image to display next
			}
		}
	}
	
}

//------------------------------------------------------------------------
// returns width of a sprite image 
//------------------------------------------------------------------------
unsigned char GetImageDimX(const unsigned char *image){
		return *(image+18);
}

//------------------------------------------------------------------------
// returns heigth of a sprite image 
//------------------------------------------------------------------------
unsigned char GetImageDimY(const unsigned char *image){
		return *(image+22);
}

//------------------------------------------------------------------------
// returns sprite X position
//------------------------------------------------------------------------
unsigned char GetPosX(struct SpriteType *Sprite){
		return Sprite->posx;
}

//------------------------------------------------------------------------
// returns sprite Y position
//------------------------------------------------------------------------
unsigned char GetPosY(struct SpriteType *Sprite){
		return Sprite->posy;
}

//------------------------------------------------------------------------
// sets sprite X position
//------------------------------------------------------------------------
void SetPosX(struct SpriteType *Sprite, unsigned char posx){
	Sprite->posx = posx;
}

//------------------------------------------------------------------------
// sets sprite Y position
//------------------------------------------------------------------------
void SetPosY(struct SpriteType *Sprite, unsigned char posy){
	Sprite->posy = posy;
}

//------------------------------------------------------------------------
// sets sprite X direction
//------------------------------------------------------------------------
void SetDirX(struct SpriteType *Sprite, unsigned char dirx){
	Sprite->dirx = dirx;
}

//------------------------------------------------------------------------
// sets sprite Y direction
//------------------------------------------------------------------------
void SetDirY(struct SpriteType *Sprite, unsigned char diry){
	Sprite->diry = diry;
}

//------------------------------------------------------------------------
// gets sprite X direction
//------------------------------------------------------------------------
unsigned char  GetDirX(struct SpriteType *Sprite){
	return Sprite->dirx;
}

//------------------------------------------------------------------------
// gets sprite Y direction
//------------------------------------------------------------------------
unsigned char GetDirY(struct SpriteType *Sprite){
	return Sprite->diry;
}

//------------------------------------------------------------------------
// returns true if sprite alive
//------------------------------------------------------------------------
unsigned char GetSpriteLife(struct SpriteType *Sprite){
		return (Sprite->live);
}

//------------------------------------------------------------------------
// set sprite life condition
//------------------------------------------------------------------------
void SetSpriteLife(struct SpriteType *Sprite, unsigned char life){
		Sprite->live = life;
}

//------------------------------------------------------------------------
// returns current sprite image
//------------------------------------------------------------------------
unsigned char *GetCurFrame(struct SpriteType *Sprite){
		
		return (unsigned char *) Sprite->frames+(Sprite->actualframe*Sprite->framesize);
}

//------------------------------------------------------------------------
// checks if two sprites are collided
// returns 1 if it's true
//------------------------------------------------------------------------
unsigned char CheckSpritesCollision(struct SpriteType *Sprite1, struct SpriteType *Sprite2){
	
	unsigned char left1, left2;
	unsigned char right1, right2;
	unsigned char top1, top2;
	unsigned char bottom1, bottom2;
	
	if (Sprite1->live && Sprite2->live) {
		
		// sprites corners positions
		left1 = Sprite1->posx;
		left2 = Sprite2->posx;
		right1 = Sprite1->posx + Sprite1->dimx;
		right2 = Sprite2->posx + Sprite2->dimx;
		top1 = Sprite1->posy - Sprite1->dimy;
		top2 = Sprite2->posy - Sprite2->dimy;
		bottom1 = Sprite1->posy;
		bottom2 = Sprite2->posy;
		
		// checks if sprites boxes intersect
		if (bottom1 < (top2+1)) return(0);
		if (top1 > (bottom2-1)) return(0);

		if (right1 < (left2+1)) return(0);
		if (left1 > (right2-1)) return(0);
		
		return 1;
	}
	
	return(0);
}

//-----------------------------------------------------------------------
// checks if a sprite is collided with ground or sky or screen right or left edge
// returns 3 if sprite and L/R edges collides
// returns 1 if sprite and ground collides
// returns 2 if sprite and sky collides
// returns 0 if no collisions
//-----------------------------------------------------------------------
unsigned char CheckSpriteWorldCollision(struct SpriteType *Sprite, struct TerrainType *Land){

	unsigned char i;

	if (Sprite->live) {
	
		// collision with terrain
		for (i=Sprite->posx;i<(Sprite->posx+Sprite->dimx);i++) {
				if (Land->landscape[i] <= (Sprite->posy+1)) {
					return 1;
				}
		}
		
		// collision with sky
		if (!(Sprite->posy - Sprite->dimy)) {
			return 2;
		}
		
		// collision with edges
		if (Sprite->posx == 0 || ((Sprite->posx + Sprite->dimx) == SCREENWIDTH)) {
			return 3;
		}
	}
	return 0;
}

//------------------------------------------------------------------------
// creates a new player sprite in the middle of left edge of the screen
// inputs:
//		player sprite to initialize
//		pointer to sprite images array
//		number of animation images
//		size of an image
//		player Y speed
//------------------------------------------------------------------------
void CreatePlayer(struct SpriteType *Sprite, const unsigned char *PlayerImages,
	               unsigned char PlayerFramesNum, unsigned long PlayerFramesSize, unsigned char PlayerSpeed){
	
	Sprite->frames = PlayerImages;
	Sprite->nframes = PlayerFramesNum;
	Sprite->framesize = PlayerFramesSize;
	Sprite->actualframe = 0;
	Sprite->dimx = GetImageDimX(Sprite->frames);
	Sprite->dimy = GetImageDimY(Sprite->frames);
	Sprite->posx = 1;
	Sprite->posy = (SCREENHEIGHT/2) - (Sprite->dimy/2);
	Sprite->speedx = 0;
	Sprite->actualspeedx = 0;
	Sprite->speedy = PlayerSpeed;
	Sprite->actualspeedy = PlayerSpeed;
	Sprite->dirx = 2;
	Sprite->diry = 2;
	Sprite->live = 1;
}

//------------------------------------------------------------------------
// create a new enemy sprite
// inputs:
//		enemy sprite to initialize
//		pointer to sprite images array
//		number of animation images
//		size of an image
//		enemy X speed
//		enemy Y speed
//		enemy initial Y position
//		enemy initial Y direction
//------------------------------------------------------------------------
void CreateEnemy(struct SpriteType *Sprite, const unsigned char *EnemyImages,
	               unsigned char EnemyFramesNum, unsigned long EnemyFramesSize, 
								 unsigned char Xspeed, unsigned char Yspeed, unsigned char Ypos,
								 unsigned char Ydir){

	Sprite->frames = EnemyImages;
	Sprite->nframes = EnemyFramesNum;
	Sprite->framesize = EnemyFramesSize;  
	Sprite->actualframe = 0;
	Sprite->dimx = GetImageDimX(Sprite->frames);
	Sprite->dimy = GetImageDimY(Sprite->frames);
	Sprite->posx = SCREENWIDTH - Sprite->dimx - 1; // enemies enter from right edge of screen
	Sprite->posy = Ypos;
	Sprite->speedx = Xspeed;
	Sprite->actualspeedx = Sprite->speedx;
	Sprite->speedy = Yspeed;
	Sprite->actualspeedy = Sprite->speedy;
	Sprite->dirx = 0; // always left X direction
	Sprite->diry = Ydir;
	Sprite->live = 1;
}

//------------------------------------------------------------------------
// create a new player rocket sprite
// Inputs:
//		rocket sprite to initialize
//		player sprite firing the rocket
//		pointer to sprite images array
//		number of animation images
//		size of an image
//		speed of rocket
//------------------------------------------------------------------------
void CreatePlayerRocket (struct SpriteType *Sprite, struct SpriteType *PlayerSprite,
													const unsigned char *PlayerRocketImages,
													unsigned char PlayerRocketFramesNum, unsigned long PlayerRocketFramesSize, 
													unsigned char PlayerRocketSpeed){
	
	Sprite->frames = PlayerRocketImages;
	Sprite->nframes = PlayerRocketFramesNum;
	Sprite->framesize = PlayerRocketFramesSize;
	Sprite->actualframe = 0;
	Sprite->dimx = GetImageDimX(Sprite->frames);
	Sprite->dimy = GetImageDimY(Sprite->frames);
	Sprite->posx = PlayerSprite->posx + PlayerSprite->dimx; // player rocket starts from player sprite
	Sprite->posy = PlayerSprite->posy - (PlayerSprite->dimy/2) + (Sprite->dimy/2);
	Sprite->speedx = PlayerRocketSpeed;
	Sprite->actualspeedx = PlayerRocketSpeed;
	Sprite->speedy = 0;
	Sprite->actualspeedy = 0;
	Sprite->dirx = 1; // always right x direction
	Sprite->diry = 2; // only orizontal movement
	Sprite->live = 1;
}

//------------------------------------------------------------------------
// create a new enemy rocket sprite
// Inputs:
//		rocket sprite to initialize
//		enemy sprite firing the rocket
//		pointer to sprite images array
//		number of animation images
//		size of an image
//		speed of rocket
//------------------------------------------------------------------------
void CreateEnemyRocket(struct SpriteType *Sprite, struct SpriteType *EnemySprite,
													const unsigned char *EnemyRocketImages,
													unsigned char EnemyRocketFramesNum, unsigned long EnemyRocketFramesSize, 
													unsigned char EnemyRocketSpeed){
	
	Sprite->frames = EnemyRocketImages;
	Sprite->nframes = EnemyRocketFramesNum;
	Sprite->framesize = EnemyRocketFramesSize;
	Sprite->actualframe = 0;
	Sprite->dimx = GetImageDimX(Sprite->frames);
	Sprite->dimy = GetImageDimY(Sprite->frames);
	Sprite->posx = EnemySprite->posx - EnemySprite->dimx; // enemy rocket starts from enemy sprite
	Sprite->posy = EnemySprite->posy - (EnemySprite->dimy/2) + (Sprite->dimy/2);
	Sprite->speedx = EnemyRocketSpeed;
	Sprite->actualspeedx = EnemyRocketSpeed;
	Sprite->speedy = 0;
	Sprite->actualspeedy = 0;
	Sprite->dirx = 0; // always left x direction
	Sprite->diry = 2; // only orizontal movement
	Sprite->live = 1;
}

//------------------------------------------------------------------------
// create a new explosion sprite
// inputs:
//		explosion sprite to initialize
//		sprite exploded
//		pointer to sprite images array
//		number of animation images
//		size of an image
//		speed of explosion (number of screen frames before display next image)
//------------------------------------------------------------------------
void CreateExplosion(struct SpriteType *Sprite, struct SpriteType *SpriteDestroyed, 
										 const unsigned char *ExplosionImages, 
										 unsigned char ExplosionFramesNum, unsigned long ExplosionFramesSize,
										 unsigned char ExplosionSpeed){
	
	Sprite->frames = ExplosionImages;
	Sprite->nframes = ExplosionFramesNum;
	Sprite->framesize = ExplosionFramesSize;
	Sprite->actualframe = 0;
	Sprite->dimx = GetImageDimX(Sprite->frames);
	Sprite->dimy = GetImageDimY(Sprite->frames);
	Sprite->posx = SpriteDestroyed->posx;   // same position as the object exploded
	Sprite->posy = SpriteDestroyed->posy;
	Sprite->speedx = ExplosionSpeed;
	Sprite->actualspeedx = ExplosionSpeed;
	Sprite->speedy = 0;
	Sprite->actualspeedy = 0;
	Sprite->dirx = 2; // no moving
	Sprite->diry = 2; // no moving
	Sprite->live = 1;
}

//------------------------------------------------------------------------
// create a initial flat terrain 5 pixels above ground
// inputs:
//		structure of terrain to initialize
//		X speed for terrain
//------------------------------------------------------------------------
void CreateLand(struct TerrainType *Land, unsigned char speed){
	
	unsigned char i;
	
	for (i=0; i<SCREENWIDTH; i++) {
			Land->landscape[i] = SCREENHEIGHT - 5;
	}
	Land->speed = speed;
	Land->actualspeed = speed;
}

//------------------------------------------------------------------------
// move terrain to the left, randomly creates new rightmost visible landscape
//------------------------------------------------------------------------
void MoveLand(struct TerrainType *Land, unsigned long rnd, unsigned long range){
	
	unsigned char i;
	unsigned char rnd2;
	
	// decrement frames to wait for next movement
	Land->actualspeed--;
	
	// it's time to move land along X axis
	if (!Land->actualspeed) {
		Land->actualspeed = Land->speed;
		
		// scrolls actual terrain to the left
		for (i=0; i<SCREENWIDTH-1; i++) {
				Land->landscape[i] = Land->landscape[i+1];
		}
		
		// random Y screen coordinate, limited to Y=15 as max altitude
		rnd2 = (unsigned char) (rnd>>16)%((range>>16)%3+2); // random number
		Land->landscape[SCREENWIDTH-1] = Land->landscape[SCREENWIDTH-2] + rnd2 - 1;
		
		if (Land->landscape[SCREENWIDTH-1] < 17) {
			Land->landscape[SCREENWIDTH-1] = 17;
		}
		if (Land->landscape[SCREENWIDTH-1] >= SCREENHEIGHT) {
			Land->landscape[SCREENWIDTH-1] = SCREENHEIGHT-1;
		}
	}
}
